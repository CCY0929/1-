<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ (é«˜æ€§èƒ½ä¼˜åŒ–ç‰ˆ)</title>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; color: white; transition: background-color 0.5s; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI é¢æ¿ä¼˜åŒ– */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 260px;
            background: rgba(20, 20, 35, 0.85); backdrop-filter: blur(12px);
            padding: 15px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10; box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            transition: opacity 0.5s ease, transform 0.5s ease;
            max-height: 90vh; overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: #00d2ff rgba(0,0,0,0.3);
        }
        
        body.immersive-mode #ui-panel, body.immersive-mode #status-indicator { opacity: 0; pointer-events: none; transform: translateY(-20px); }
        body.immersive-mode { cursor: none; }

        /* é¢„è§ˆçª—å£ */
        #video-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px;
            background: #000; border-radius: 8px; border: 2px solid rgba(255, 255, 255, 0.15);
            z-index: 10; object-fit: cover; transform: scaleX(-1); opacity: 1; transition: opacity 0.3s;
        }
        #video-preview.hidden { opacity: 0 !important; pointer-events: none; }
        body.immersive-mode #video-preview { opacity: 0.7; bottom: 30px; right: 30px; }

        h2 { margin: 0 0 10px 0; font-size: 16px; text-transform: uppercase; letter-spacing: 1px; background: linear-gradient(90deg, #00d2ff 0%, #3a7bd5 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .control-group { margin-bottom: 12px; }
        label { display: block; margin-bottom: 5px; font-size: 11px; color: #ccc; }
        
        select, input[type="text"], input[type="color"] {
            width: 100%; padding: 6px; background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 4px;
            color: white; outline: none; font-size: 12px;
        }
        select option { background: #1a1a2e; }

        /* ç»Ÿä¸€æŒ‰é’®æ ·å¼ */
        .btn {
            width: 100%; padding: 8px; border: none; border-radius: 4px;
            color: white; font-weight: 600; cursor: pointer; transition: all 0.2s;
            margin-top: 8px; font-size: 12px; text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .btn-primary { background: linear-gradient(90deg, #00d2ff 0%, #3a7bd5 100%); }
        .btn-upload { background: linear-gradient(90deg, #ff9966 0%, #ff5e62 100%); }
        .btn-ai { background: linear-gradient(90deg, #a18cd1 0%, #fbc2eb 100%); color: #4a2c52; }
        .btn-save { background: linear-gradient(90deg, #11998e 0%, #38ef7d 100%); }
        .btn-delete { background: rgba(255, 71, 87, 0.15); color: #ff6b81; border: 1px solid rgba(255, 71, 87, 0.3); }
        .btn-outline { background: transparent; border: 1px solid rgba(255, 255, 255, 0.2); color: #ddd; }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn-outline:hover { border-color: #00d2ff; color: #fff; }

        #ai-panel, #debug-panel, #image-depth-control { display: none; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-top: 8px; border: 1px solid rgba(255,255,255,0.05); }
        #ai-panel.show, #debug-panel.show { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status-indicator { position: absolute; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 6px; align-items: flex-end; z-index: 10; pointer-events: none; }
        .status-badge { background: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 15px; display: flex; align-items: center; gap: 6px; font-size: 11px; border: 1px solid rgba(255,255,255,0.1); }
        .dot { width: 6px; height: 6px; border-radius: 50%; background: #555; transition: 0.3s; }
        .dot.active-left { background: #ff9f43; box-shadow: 0 0 6px #ff9f43; }
        .dot.active-right { background: #2ed573; box-shadow: 0 0 6px #2ed573; }

        /* åŠ è½½ä¸æç¤º */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; font-size: 20px; pointer-events: none; display: none; }
        #toast { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); color: #fff; padding: 8px 16px; border-radius: 20px; font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 100; border: 1px solid rgba(255,255,255,0.15); }
        #exit-hint { position: absolute; top: 20px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 12px; z-index: 5; opacity: 0; pointer-events: none; }

        /* æŒ‡å—å¼¹çª— */
        .guide-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); z-index: 1000; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .guide-modal-overlay.show { opacity: 1; pointer-events: auto; }
        .guide-content { background: #1e1e24; border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; padding: 25px; width: 90%; max-width: 480px; text-align: center; transform: translateY(20px); transition: transform 0.3s; }
        .guide-modal-overlay.show .guide-content { transform: translateY(0); }
        .guide-flex { display: flex; gap: 15px; margin: 20px 0; }
        .guide-col { flex: 1; background: rgba(255,255,255,0.03); padding: 12px; border-radius: 8px; }
        .gesture-icon { font-size: 22px; display: block; margin-bottom: 4px; }
        .gesture-desc { font-size: 11px; color: #999; line-height: 1.4; }
        
        /* è°ƒè¯•ç»„ä»¶ */
        .debug-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 11px; color: #aaa; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: #444; border-radius: 2px; outline: none; padding: 0; border: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #00d2ff; border-radius: 50%; cursor: pointer; }
        .toggle-switch { position: relative; width: 30px; height: 16px; display: inline-block; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 16px; }
        .slider:before { position: absolute; content: ""; height: 12px; width: 12px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2ed573; }
        input:checked + .slider:before { transform: translateX(14px); }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</div>
    <div id="toast"></div>
    <div id="exit-hint">ç‚¹å‡»å±å¹•é€€å‡ºæ²‰æµ¸æ¨¡å¼</div>

    <div id="gesture-guide-modal" class="guide-modal-overlay">
        <div class="guide-content">
            <div style="font-size: 18px; font-weight: bold; color: #00d2ff; margin-bottom: 15px;">ğŸ‘‹ 360Â° åŒæ‰‹æ“æ§æŒ‡å—</div>
            <div class="guide-flex">
                <div class="guide-col" style="border: 1px solid rgba(255, 159, 67, 0.3);">
                    <h3 style="color: #ff9f43; margin:0 0 10px 0; font-size: 14px;">âœ‹ å·¦æ‰‹ (ä½ç§»)</h3>
                    <div style="margin-bottom:10px;"><span class="gesture-icon">â†”ï¸</span><div class="gesture-desc"><b>æ‹–æ‹½</b> æ—‹è½¬æ¨¡å‹</div></div>
                    <div><span class="gesture-icon">âœŠ</span><div class="gesture-desc"><b>æ¡æ‹³</b> æš‚åœæ§åˆ¶</div></div>
                </div>
                <div class="guide-col" style="border: 1px solid rgba(46, 213, 115, 0.3);">
                    <h3 style="color: #2ed573; margin:0 0 10px 0; font-size: 14px;">ğŸ¤š å³æ‰‹ (åŠŸèƒ½)</h3>
                    <div style="margin-bottom:10px;"><span class="gesture-icon">ğŸ‘Œ</span><div class="gesture-desc"><b>æåˆ</b> ç¼©æ”¾å¤§å°</div></div>
                    <div><span class="gesture-icon">ğŸ’¨</span><div class="gesture-desc"><b>æŒ¥æ‰‹</b> åˆ‡æ¢æ¨¡å‹</div></div>
                </div>
            </div>
            <button id="close-guide-btn" class="btn btn-primary" style="width: 50%;">æˆ‘å‡†å¤‡å¥½äº†</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="status-indicator">
        <div class="status-badge"><div class="dot" id="left-hand-dot"></div><span id="left-status-text">å·¦æ‰‹: ç©ºé—²</span></div>
        <div class="status-badge"><div class="dot" id="right-hand-dot"></div><span id="right-status-text">å³æ‰‹: ç©ºé—²</span></div>
    </div>

    <div id="ui-panel">
        <h2>äº¤äº’ç²’å­ç³»ç»Ÿ Pro</h2>
        
        <div class="control-group">
            <label>é€‰æ‹©æ¨¡å‹</label>
            <select id="shape-select">
                <optgroup label="ğŸ“‚ æˆ‘çš„æ”¶è—" id="saved-models-group"><option value="none" disabled>æš‚æ— æ”¶è—</option></optgroup>
                <optgroup label="ğŸŒŸ åŸºç¡€"><option value="heart">çˆ±å¿ƒ (Heart)</option><option value="flower">èŠ±æœµ (Flower)</option><option value="sphere">çƒä½“ (Sphere)</option><option value="cube">ç«‹æ–¹ä½“ (Cube)</option><option value="ring">åœ†ç¯ (Ring)</option></optgroup>
                <optgroup label="ğŸš€ é«˜çº§"><option value="galaxy">é“¶æ²³ (Galaxy)</option><option value="atom">åŸå­ (Atom)</option><option value="blackhole">é»‘æ´ (BlackHole)</option><option value="mobius">è«æ¯”ä¹Œæ–¯ç¯</option><option value="dna">DNA åŒèºæ—‹</option><option value="tornado">é¾™å·é£</option></optgroup>
                <optgroup label="ğŸ¨ åˆ›æ„"><option value="ai_custom" disabled id="opt-ai">âœ¨ AI ç”Ÿæˆ</option><option value="image_model" disabled id="opt-image">ğŸ–¼ï¸ å›¾ç‰‡æ¨¡å‹</option></optgroup>
            </select>
        </div>

        <div class="control-group">
            <label>ç²’å­åŸºè‰²</label>
            <input type="color" id="color-picker" value="#00d2ff">
        </div>

        <button id="ai-toggle-btn" class="btn btn-ai">âœ¨ AI åˆ›æ„ç”Ÿæˆ</button>
        <div id="ai-panel">
            <label style="color: #fbc2eb;">æè¿°å½¢çŠ¶</label>
            <input type="text" id="ai-prompt" placeholder="ä¾‹ï¼šå·¨å¤§çš„ç”œç”œåœˆï¼ŒåŒèºæ—‹...">
            <button id="ai-generate-btn" class="btn btn-ai" style="margin-top: 5px;">ğŸ”® ç”Ÿæˆä»£ç </button>
            <button id="save-model-btn" class="btn btn-save" style="display:none;">ğŸ’¾ ä¿å­˜æ¨¡å‹</button>
            <div id="ai-status" style="font-size: 10px; color: #aaa; margin-top: 5px;"></div>
        </div>

        <div class="control-group" style="border-top: 1px solid rgba(255,255,255,0.1); margin-top: 10px; padding-top: 10px;">
            <label>æ•°æ®ç®¡ç†</label>
            <div style="display: flex; gap: 5px;">
                <button id="export-btn" class="btn btn-outline" style="margin-top:0;">ğŸ“¤ å¯¼å‡º</button>
                <button id="import-btn" class="btn btn-outline" style="margin-top:0;" onclick="document.getElementById('model-file-input').click()">ğŸ“¥ å¯¼å…¥</button>
            </div>
            <input type="file" id="model-file-input" accept=".json" style="display: none;" onchange="importModelFile(this)">
        </div>

        <div class="control-group" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; margin-top: 10px;">
            <label>å›¾ç‰‡ 3D åŒ–</label>
            <input type="file" id="image-upload" accept="image/*" style="display: none;" onclick="this.value=null">
            <button class="btn btn-upload" onclick="document.getElementById('image-upload').click()">ğŸ–¼ï¸ ä¸Šä¼ å›¾ç‰‡</button>
            <div id="image-depth-control">
                <div class="debug-row"><span style="color: #ff9966;">ğŸ§Š ç«‹ä½“æ·±åº¦</span><span id="depth-val">5.0</span></div>
                <input type="range" id="image-depth-slider" min="0" max="15" step="0.5" value="5.0">
            </div>
        </div>

        <button id="camera-btn" class="btn btn-primary">ğŸ“· å¼€å¯æ‘„åƒå¤´</button>
        <button id="toggle-preview-btn" class="btn btn-outline">ğŸ‘ï¸ éšè—é¢„è§ˆ</button>
        <button id="swap-hands-btn" class="btn btn-outline">ğŸ‘ äº¤æ¢å·¦å³æ‰‹</button>
        <button id="guide-btn" class="btn btn-outline">ğŸ“– å¸®åŠ©</button>
        <button id="fullscreen-btn" class="btn btn-outline">å…¨å±æ²‰æµ¸</button>
        
        <button id="debug-toggle-btn" class="btn btn-debug">ğŸ› ï¸ æ€§èƒ½è®¾ç½®</button>
        <div id="debug-panel">
            <div class="debug-row"><span style="color: #00d2ff;">ğŸ”„ è‡ªåŠ¨æ—‹è½¬</span><label class="toggle-switch"><input type="checkbox" id="auto-rotate-toggle"><span class="slider"></span></label></div>
            <div class="debug-row"><span>ğŸš€ æé€Ÿæ¨¡å¼ (Lite)</span><label class="toggle-switch"><input type="checkbox" id="perf-mode-toggle"><span class="slider"></span></label></div>
            <div class="debug-row"><span>æ—‹è½¬çµæ•åº¦</span><span id="rot-val">1.0</span></div>
            <input type="range" id="rot-slider" min="0.1" max="3.0" step="0.1" value="1.0">
            <div class="debug-row" style="margin-top:5px;"><span>ç¼©æ”¾çµæ•åº¦</span><span id="zoom-val">3.5</span></div>
            <input type="range" id="zoom-slider" min="1.0" max="8.0" step="0.5" value="3.5">
            <button id="clear-storage-btn" class="btn btn-delete">ğŸ—‘ï¸ æ¸…ç©ºæ”¶è—</button>
        </div>
    </div>

    <video id="input-video" style="display:none"></video>
    <canvas id="image-processing-canvas" style="display:none"></canvas>
    <canvas id="video-preview"></canvas>

    <script>
        // --- 1. å…¨å±€é…ç½® ---
        const loadingDiv = document.getElementById('loading');
        const videoElement = document.getElementById('input-video');
        const previewCanvas = document.getElementById('video-preview');
        const previewCtx = previewCanvas.getContext('2d');
        const leftStatusText = document.getElementById('left-status-text');
        const rightStatusText = document.getElementById('right-status-text');
        const apiKey = ""; 

        // æ ¸å¿ƒå‚æ•°
        let PARTICLE_COUNT = 40000; // æå‡è‡³4ä¸‡ç²’å­
        let swapHandRoles = false; 
        let GLOBAL_ROTATION_SENSITIVITY = 1.0;
        let GLOBAL_ZOOM_SENSITIVITY = 3.5; 
        let GLOBAL_SWIPE_THRESHOLD = 0.025;
        let PERFORMANCE_MODE = false;
        let AUTO_ROTATE = false;

        let savedModels = JSON.parse(localStorage.getItem('saved_particle_models') || '[]');
        let currentAICode = null; 
        let currentAIColor = null;
        let processedImagePixels = [];

        // æ‰‹åŠ¿çŠ¶æ€
        let smoothedHandX = 0.5, smoothedHandY = 0.5;
        let targetRotationX = 0, targetRotationY = 0;
        let lastLeftHandPos = null;
        let isLeftHandActive = false;
        let pendingSwipeDir = 0, swipeConfirmationStartTime = 0;
        const SWIPE_WAIT_TIME = 1500;

        // åŠ¨ç”»ä¼˜åŒ–æ ‡å¿—
        let handScaleFactor = 1.0, targetHandScale = 1.0;
        let lastShapeChangeTime = 0;
        
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.innerText = message; toast.style.opacity = '1';
            setTimeout(() => { toast.style.opacity = '0'; }, 3000);
        }

        // --- 2. Three.js åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30; camera.position.y = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // æ€§èƒ½ä¼˜åŒ–ï¼šé™åˆ¶æœ€å¤§åƒç´ æ¯”ä¸º 2ï¼Œé¿å… 4k å±å¡é¡¿
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        container.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        // æ€§èƒ½ä¼˜åŒ–ï¼šå‘Šè¯‰ GPU è¿™æ˜¯ä¸€ä¸ªåŠ¨æ€æ›´æ–°çš„ Buffer
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(PARTICLE_COUNT * 3), 3).setUsage(THREE.DynamicDrawUsage));
        geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(PARTICLE_COUNT * 3), 3).setUsage(THREE.DynamicDrawUsage));

        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.color.array;
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const targetColors = new Float32Array(PARTICLE_COUNT * 3); 
        const defaultColor = new THREE.Color('#00d2ff');
        let isImageMode = false;
        
        // åˆå§‹å¡«å……
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            positions[ix] = (Math.random() - 0.5) * 100;
            positions[ix+1] = (Math.random() - 0.5) * 100;
            positions[ix+2] = (Math.random() - 0.5) * 100;
            targetPositions[ix] = positions[ix];
            targetPositions[ix+1] = positions[ix+1];
            targetPositions[ix+2] = positions[ix+2];
            colors[ix] = defaultColor.r; colors[ix+1] = defaultColor.g; colors[ix+2] = defaultColor.b;
            targetColors[ix] = defaultColor.r; targetColors[ix+1] = defaultColor.g; targetColors[ix+2] = defaultColor.b;
        }

        const material = new THREE.PointsMaterial({
            size: 0.12, vertexColors: true, transparent: true, opacity: 0.9,
            blending: THREE.AdditiveBlending, depthWrite: false
        });
        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        const imageCanvas = document.getElementById('image-processing-canvas');
        const imageCtx = imageCanvas.getContext('2d');
        let customImagePositions = [], customImageColors = [];

        // --- 3. å½¢çŠ¶ç”Ÿæˆå™¨ ---
        const shapes = {
            heart: (i) => {
                const t = Math.random() * Math.PI * 2, r = Math.sqrt(Math.random()); 
                const x = 16 * Math.pow(Math.sin(t), 3), y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                return [x * 0.5 * r, y * 0.5 * r, (Math.random() - 0.5) * 5];
            },
            flower: (i) => {
                const angle = (i / PARTICLE_COUNT) * Math.PI * 40, r = 5 + Math.sin(angle * 5) * 3 + Math.random();
                return [Math.cos(angle) * r, Math.sin(angle) * r, (Math.random() - 0.5) * 2];
            },
            sphere: (i) => {
                const r = 8, theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
            },
            cube: (i) => { const s = 12; return [(Math.random()-0.5)*s, (Math.random()-0.5)*s, (Math.random()-0.5)*s]; },
            ring: (i) => { const t = Math.random() * Math.PI * 2, r = 8 + (Math.random()-0.5)*2; return [r*Math.cos(t), (Math.random()-0.5), r*Math.sin(t)]; },
            galaxy: (i) => {
                const arms = 3, spin = i / (PARTICLE_COUNT/arms), angle = spin * Math.PI * 2, r = Math.pow(Math.random(), 2) * 12;
                const fa = angle + (Math.floor(spin)/arms) * Math.PI * 2;
                return [Math.cos(fa) * r, (Math.random()-0.5) * (12-r) * 0.15, Math.sin(fa) * r];
            },
            atom: (i) => {
                if(Math.random()<0.15) { const r=1.5*Math.cbrt(Math.random()), t=Math.random()*6.28, p=Math.acos(2*Math.random()-1); return [r*Math.sin(p)*Math.cos(t), r*Math.sin(p)*Math.sin(t), r*Math.cos(p)]; }
                const o = i%3, t = Math.random()*6.28, r = 7+Math.random()*0.5, x0 = r*Math.cos(t), y0 = r*Math.sin(t);
                return o===0 ? [x0, (Math.random()-0.5)*0.5, y0] : (o===1 ? [x0, y0*0.5, y0*0.866] : [x0, y0*0.5, -y0*0.866]);
            },
            blackhole: (i) => {
                if(Math.random()<0.1) { const h=(Math.random()-0.5)*20, r=0.5*(1-Math.abs(h)/15); return [(Math.random()-0.5)*r, h, (Math.random()-0.5)*r]; }
                const a=Math.random()*6.28, d=3+Math.random()*10; return [Math.cos(a)*d, (Math.random()-0.5)*(15/d), Math.sin(a)*d];
            },
            mobius: (i) => {
                const u=(i/PARTICLE_COUNT)*Math.PI*2, v=(Math.random()-0.5)*2, r=6, x=(r+v/2*Math.cos(u/2))*Math.cos(u), y=(r+v/2*Math.cos(u/2))*Math.sin(u), z=v/2*Math.sin(u/2); return [x, z, y];
            },
            klein: (i) => {
                const u=(i/PARTICLE_COUNT)*Math.PI*2, v=Math.random()*6.28, r=4-2*Math.cos(u);
                return [(r*Math.cos(v)+Math.sin(u)+2*Math.sin(2*u))*0.8, (r*Math.sin(v))*0.8, (Math.sin(u)+2*Math.cos(2*u))*0.8];
            },
            dna: (i) => {
                const t=(i/PARTICLE_COUNT)*31.4, s=Math.random()>0.5, y=(i/PARTICLE_COUNT)*20-10;
                if(Math.random()<0.1) return [(Math.random()*2-1)*3, y, Math.random()*3];
                return [3*Math.cos(t+(s?0:3.14)), y, 3*Math.sin(t+(s?0:3.14))];
            },
            tornado: (i) => { const h=(i/PARTICLE_COUNT)*15-7.5, r=1+Math.abs(h)*0.8+Math.random(); return [r*Math.cos(h*2), h, r*Math.sin(h*2)]; }
        };
        const shapeKeys = Object.keys(shapes);
        let currentShapeIndex = 0;

        // --- 4. æ ¸å¿ƒé€»è¾‘ ---
        function morphTo(shapeName) {
            isImageMode = (shapeName === 'image_model');
            // æ ‡è®°å½¢çŠ¶æ”¹å˜æ—¶é—´ï¼Œç”¨äºå”¤é†’æ¸²æŸ“å¾ªç¯
            lastShapeChangeTime = Date.now();
            
            if (isImageMode && customImagePositions.length > 0) {
                const numPoints = customImagePositions.length / 3;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const idx = (i % numPoints) * 3;
                    targetPositions[i*3] = customImagePositions[idx];
                    targetPositions[i*3+1] = customImagePositions[idx+1];
                    targetPositions[i*3+2] = customImagePositions[idx+2];
                }
            } else {
                const generator = shapes[shapeName] || shapes.heart;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    try {
                        const p = generator(i);
                        targetPositions[i*3] = isNaN(p[0]) ? 0 : p[0];
                        targetPositions[i*3+1] = isNaN(p[1]) ? 0 : p[1];
                        targetPositions[i*3+2] = isNaN(p[2]) ? 0 : p[2];
                    } catch (e) { targetPositions[i*3]=0; targetPositions[i*3+1]=0; targetPositions[i*3+2]=0; }
                }
            }
            if (isImageMode && customImageColors.length > 0) {
                const numPoints = customImageColors.length / 3;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const idx = (i % numPoints) * 3;
                    targetColors[i*3] = customImageColors[idx];
                    targetColors[i*3+1] = customImageColors[idx+1];
                    targetColors[i*3+2] = customImageColors[idx+2];
                }
            } else {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    targetColors[i*3] = defaultColor.r; targetColors[i*3+1] = defaultColor.g; targetColors[i*3+2] = defaultColor.b;
                }
            }
            const selectEl = document.getElementById('shape-select');
            if(selectEl) selectEl.value = shapeName;
            const imgControls = document.getElementById('image-depth-control');
            if(imgControls) imgControls.style.display = isImageMode ? 'block' : 'none';
        }
        
        function cycleShape(direction) {
            let nextIndex = (currentShapeIndex + direction + shapeKeys.length) % shapeKeys.length;
            currentShapeIndex = nextIndex;
            const newShapeName = shapeKeys[currentShapeIndex];
            if (newShapeName === 'image_model' && customImagePositions.length === 0) { cycleShape(direction); return; }
            morphTo(newShapeName);
            showToast(`å·²åˆ‡æ¢: ${newShapeName.toUpperCase()}`);
        }

        morphTo('heart');

        // æ›´æ–°å›¾ç‰‡æ·±åº¦
        function updateImageGeometry() {
            const depthScale = parseFloat(document.getElementById('image-depth-slider').value);
            document.getElementById('depth-val').innerText = depthScale.toFixed(1);
            if (processedImagePixels.length === 0) return;
            const pos = [], col = [];
            for (let i = 0; i < processedImagePixels.length; i++) {
                const p = processedImagePixels[i];
                pos.push(p.x, p.y, (p.luminance - 0.5) * depthScale);
                col.push(p.r, p.g, p.b);
            }
            customImagePositions = pos; customImageColors = col;
            if (isImageMode) {
                const num = customImagePositions.length / 3;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const idx = (i % num) * 3;
                    targetPositions[i*3] = customImagePositions[idx];
                    targetPositions[i*3+1] = customImagePositions[idx+1];
                    targetPositions[i*3+2] = customImagePositions[idx+2];
                }
                lastShapeChangeTime = Date.now(); // å”¤é†’æ¸²æŸ“
            }
        }
        document.getElementById('image-depth-slider').addEventListener('input', updateImageGeometry);

        function processImageToParticles(image) {
            const maxSize = 200; 
            let w = image.width, h = image.height;
            if (w > maxSize || h > maxSize) { const r = Math.min(maxSize/w, maxSize/h); w=Math.floor(w*r); h=Math.floor(h*r); }
            imageCanvas.width = w; imageCanvas.height = h;
            imageCtx.drawImage(image, 0, 0, w, h);
            const data = imageCtx.getImageData(0, 0, w, h).data;
            processedImagePixels = [];
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    if (data[i+3] > 128) {
                        const r=data[i]/255, g=data[i+1]/255, b=data[i+2]/255;
                        processedImagePixels.push({
                            x: (x - w/2)*0.15, y: -(y - h/2)*0.15,
                            r:r, g:g, b:b, luminance: 0.2126*r + 0.7152*g + 0.0722*b
                        });
                    }
                }
            }
            if (processedImagePixels.length === 0) { showToast("æ— æ•ˆå›¾ç‰‡"); return; }
            updateImageGeometry();
            const opt = document.getElementById('opt-image'); opt.disabled = false; opt.text = "ğŸ–¼ï¸ å½“å‰ç«‹ä½“æ¨¡å‹";
            document.getElementById('shape-select').value = 'image_model';
            morphTo('image_model');
            showToast("3D ç«‹ä½“æ¨¡å‹å·²ç”Ÿæˆ");
        }

        // --- æ¸²æŸ“å¾ªç¯ (æ€§èƒ½ä¼˜åŒ–ç‰ˆ) ---
        function animate() {
            requestAnimationFrame(animate);

            // å¹³æ»‘ç¼©æ”¾
            handScaleFactor += (targetHandScale - handScaleFactor) * 0.2;
            
            // è‡ªåŠ¨æ—‹è½¬
            if (!isLeftHandActive && AUTO_ROTATE) targetRotationY += 0.005;

            // å®¹å™¨æ•´ä½“æ—‹è½¬ (GPUå¤„ç†ï¼Œå¼€é”€æå°)
            particleSystem.rotation.y += (targetRotationY - particleSystem.rotation.y) * 0.1;
            particleSystem.rotation.x += (targetRotationX - particleSystem.rotation.x) * 0.1;

            // --- æ™ºèƒ½ä¼‘çœ ä¼˜åŒ– ---
            // å¦‚æœ: 1. ç¼©æ”¾å·²ç¨³å®š 2. å½¢çŠ¶å·²ç¨³å®š(2ç§’æ— å˜åŒ–) -> è·³è¿‡ CPU ç²’å­éå†
            const isScaleStable = Math.abs(targetHandScale - handScaleFactor) < 0.001;
            const isShapeStable = (Date.now() - lastShapeChangeTime) > 2000;

            if (isScaleStable && isShapeStable) {
                // è¿›å…¥ä½åŠŸè€—æ¨¡å¼ï¼Œä»…æ¸²æŸ“ä¸è®¡ç®—
                renderer.render(scene, camera);
                return;
            }

            // æ´»è·ƒçŠ¶æ€ï¼šCPU ç²’å­æ’å€¼
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3, iy = i*3+1, iz = i*3+2;
                const tx = targetPositions[ix] * handScaleFactor;
                const ty = targetPositions[iy] * handScaleFactor;
                const tz = targetPositions[iz] * handScaleFactor;

                // ç®€å•çš„ Ease-out æ’å€¼
                positions[ix] += (tx - positions[ix]) * 0.05;
                positions[iy] += (ty - positions[iy]) * 0.05;
                positions[iz] += (tz - positions[iz]) * 0.05;

                colors[ix] += (targetColors[ix] - colors[ix]) * 0.05;
                colors[iy] += (targetColors[iy] - colors[iy]) * 0.05;
                colors[iz] += (targetColors[iz] - colors[iz]) * 0.05;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- äº¤äº’é€»è¾‘ ---
        let hands, cameraUtils;
        function dist(p1, p2) { return Math.sqrt(Math.pow(p1.x-p2.x,2) + Math.pow(p1.y-p2.y,2)); }
        function isFist(lm) { return dist(lm[8], lm[0]) < 0.2 && dist(lm[12], lm[0]) < 0.2; }

        function onResults(results) {
            previewCtx.save();
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
            
            let lh = false, rh = false;
            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const lm = results.multiHandLandmarks[i];
                    const lbl = results.multiHandedness[i].label;
                    const isLeft = swapHandRoles ? (lbl === 'Right') : (lbl === 'Left');
                    const color = isLeft ? '#ff9f43' : '#2ed573';
                    
                    drawConnectors(previewCtx, lm, HAND_CONNECTIONS, {color: color, lineWidth: 2});
                    drawLandmarks(previewCtx, lm, {color: '#fff', lineWidth: 1});

                    if (isLeft) {
                        lh = true; isLeftHandActive = true;
                        if (isFist(lm)) {
                            leftStatusText.innerText = "å·¦æ‰‹: âœŠ æš‚åœ"; lastLeftHandPos = null;
                        } else {
                            smoothedHandX += (lm[9].x - smoothedHandX) * 0.15;
                            smoothedHandY += (lm[9].y - smoothedHandY) * 0.15;
                            if (lastLeftHandPos) {
                                const dx = smoothedHandX - lastLeftHandPos.x, dy = smoothedHandY - lastLeftHandPos.y;
                                targetRotationY += dx * GLOBAL_ROTATION_SENSITIVITY * 5.0;
                                targetRotationX += dy * GLOBAL_ROTATION_SENSITIVITY * 5.0;
                                leftStatusText.innerText = "å·¦æ‰‹: â†”ï¸ æ‹–æ‹½ä¸­";
                            }
                            lastLeftHandPos = { x: smoothedHandX, y: smoothedHandY };
                        }
                    } else {
                        rh = true;
                        if (pendingSwipeDir !== 0) {
                            if (SWIPE_WAIT_TIME - (Date.now() - swipeConfirmationStartTime) <= 0) { pendingSwipeDir = 0; rightStatusText.innerText = "è¶…æ—¶"; }
                            else {
                                rightStatusText.innerText = "è¯·æ¡æ‹³ç¡®è®¤ âœŠ";
                                if (isFist(lm)) { cycleShape(pendingSwipeDir); pendingSwipeDir = 0; }
                            }
                        } else {
                            const d = dist(lm[4], lm[8]);
                            const norm = Math.max(0, Math.min(1, (d - 0.02) / 0.23));
                            targetHandScale = 0.3 + norm * (GLOBAL_ZOOM_SENSITIVITY - 0.3);
                            // å”¤é†’æ¸²æŸ“å¾ªç¯ï¼ˆå½“æ‰‹åŠ¿ç¼©æ”¾å˜åŒ–æ—¶ï¼‰
                            if (Math.abs(targetHandScale - handScaleFactor) > 0.01) lastShapeChangeTime = Date.now();
                            rightStatusText.innerText = `ç¼©æ”¾: ${(targetHandScale*100).toFixed(0)}%`;

                            // æŒ¥æ‰‹æ£€æµ‹
                            const wr = lm[0];
                            if (window.lastWrX && (Date.now() - window.lastSwT > 600)) {
                                if (Math.abs(wr.x - window.lastWrX) > GLOBAL_SWIPE_THRESHOLD) {
                                    pendingSwipeDir = (wr.x < window.lastWrX) ? 1 : -1;
                                    swipeConfirmationStartTime = Date.now();
                                }
                            }
                            window.lastWrX = wr.x; window.lastSwT = window.lastSwT || 0;
                            if(Date.now() - window.lastSwT > 600 && Math.abs(wr.x - (window.lastWrX||0)) > 0.01) window.lastSwT = Date.now();
                        }
                    }
                }
            }
            if (!lh) { document.getElementById('left-hand-dot').classList.remove('active-left'); leftStatusText.innerText = "å·¦æ‰‹: ç©ºé—²"; lastLeftHandPos = null; isLeftHandActive = false; }
            else document.getElementById('left-hand-dot').classList.add('active-left');
            
            if (!rh) { document.getElementById('right-hand-dot').classList.remove('active-right'); rightStatusText.innerText = "å³æ‰‹: ç©ºé—²"; }
            else document.getElementById('right-hand-dot').classList.add('active-right');
            
            previewCtx.restore();
        }

        async function startCamera() {
            loadingDiv.style.display = 'block';
            document.getElementById('camera-btn').disabled = true;
            try {
                hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });
                hands.onResults(onResults);
                cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
                await cameraUtils.start();
                loadingDiv.style.display = 'none'; document.getElementById('camera-btn').style.display = 'none';
            } catch (e) { console.error(e); loadingDiv.style.display = 'none'; document.getElementById('camera-btn').disabled = false; showToast("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥"); }
        }

        // --- è¾…åŠ©åŠŸèƒ½ (ä¿å­˜/åŠ è½½/å¯¼å‡º) ---
        function saveModel() {
            if (!currentAICode) return showToast("æ—  AI æ¨¡å‹");
            const name = prompt("æ¨¡å‹å‘½å:", `AI Model ${savedModels.length+1}`);
            if (name) {
                savedModels.push({ name, code: currentAICode, color: currentAIColor, type: 'ai' });
                localStorage.setItem('saved_particle_models', JSON.stringify(savedModels));
                refreshModelList(); showToast("å·²ä¿å­˜");
            }
        }
        function loadModel(idx) {
            const m = savedModels[idx];
            if (m.type === 'ai') {
                try { shapes['saved_'+idx] = new Function('i', m.code); defaultColor.set(m.color); document.getElementById('color-picker').value = m.color; morphTo('saved_'+idx); showToast(`åŠ è½½: ${m.name}`); } 
                catch(e) { showToast("åŠ è½½å¤±è´¥"); }
            }
        }
        function refreshModelList() {
            const grp = document.getElementById('saved-models-group'); grp.innerHTML = '';
            if (savedModels.length === 0) grp.innerHTML = '<option value="none" disabled>æš‚æ— æ”¶è—</option>';
            else savedModels.forEach((m, i) => { const o = document.createElement('option'); o.value = 'saved_'+i; o.text = `ğŸ’¾ ${m.name}`; grp.appendChild(o); if(m.type==='ai') shapes['saved_'+i]=new Function('i', m.code); });
        }
        function exportModel() {
            const v = document.getElementById('shape-select').value;
            let data = null, fname = "model.json";
            if (v === 'ai_custom' && currentAICode) { data = {type:'ai', name:'Custom AI', code:currentAICode, color:currentAIColor}; fname="ai_model.json"; }
            else if (v === 'image_model' && customImagePositions.length) { data = {type:'image', name:'Image 3D', positions:Array.from(customImagePositions), colors:Array.from(customImageColors)}; fname="image_model.json"; }
            else if (v.startsWith('saved_')) { const i=parseInt(v.split('_')[1]); if(savedModels[i]) { data=savedModels[i]; fname=(savedModels[i].name||"saved")+".json"; } }
            else { data = {type:'builtin', name:v, color:document.getElementById('color-picker').value}; fname=v+".json"; }
            if(!data) return showToast("æ— æ³•å¯¼å‡º");
            const a = document.createElement('a'); a.href = "data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(data)); a.download = fname; a.click();
        }
        function importModelFile(inp) {
            const f = inp.files[0]; if(!f) return;
            const r = new FileReader();
            r.onload = (e) => {
                try {
                    const d = JSON.parse(e.target.result), name = d.name||"Imported";
                    if(d.type==='ai' || d.code) { currentAICode=d.code; currentAIColor=d.color; shapes.ai_custom=new Function('i', d.code); defaultColor.set(d.color); document.getElementById('color-picker').value=d.color; document.getElementById('opt-ai').disabled=false; document.getElementById('shape-select').value='ai_custom'; morphTo('ai_custom'); }
                    else if(d.type==='image') { customImagePositions=d.positions; customImageColors=d.colors; document.getElementById('opt-image').disabled=false; document.getElementById('shape-select').value='image_model'; morphTo('image_model'); }
                    else if(d.type==='builtin' && shapeKeys.includes(d.name)) { defaultColor.set(d.color); document.getElementById('color-picker').value=d.color; document.getElementById('shape-select').value=d.name; morphTo(d.name); }
                    showToast(`å·²å¯¼å…¥: ${name}`);
                } catch(err){ showToast("æ–‡ä»¶æ ¼å¼é”™è¯¯"); }
                inp.value = '';
            };
            r.readAsText(f);
        }

        // --- äº‹ä»¶ç»‘å®š ---
        document.getElementById('camera-btn').onclick = startCamera;
        document.getElementById('save-model-btn').onclick = saveModel;
        document.getElementById('export-btn').onclick = exportModel;
        document.getElementById('import-btn').onclick = () => document.getElementById('model-file-input').click();
        document.getElementById('image-upload').onchange = (e) => { if(e.target.files[0]) { const r=new FileReader(); r.onload=(ev)=>{const i=new Image(); i.onload=()=>processImageToParticles(i); i.src=ev.target.result;}; r.readAsDataURL(e.target.files[0]); } };
        document.getElementById('clear-storage-btn').onclick = () => { if(confirm("æ¸…ç©ºæ”¶è—?")) { localStorage.removeItem('saved_particle_models'); savedModels=[]; refreshModelList(); } };
        document.getElementById('swap-hands-btn').onclick = () => { swapHandRoles=!swapHandRoles; showToast(swapHandRoles?"å·¦æ‰‹åŠŸèƒ½äº’æ¢":"åŠŸèƒ½å¤ä½"); };
        document.getElementById('toggle-preview-btn').onclick = (e) => { const p=document.getElementById('video-preview'); p.classList.toggle('hidden'); e.target.innerText=p.classList.contains('hidden')?'ğŸ‘ï¸ æ˜¾ç¤ºé¢„è§ˆ':'ğŸ‘ï¸ éšè—é¢„è§ˆ'; };
        
        // è°ƒè¯•é¢æ¿
        document.getElementById('debug-toggle-btn').onclick = () => document.getElementById('debug-panel').classList.toggle('show');
        document.getElementById('ai-toggle-btn').onclick = () => document.getElementById('ai-panel').classList.toggle('show');
        document.getElementById('guide-btn').onclick = () => document.getElementById('gesture-guide-modal').classList.add('show');
        document.getElementById('close-guide-btn').onclick = () => document.getElementById('gesture-guide-modal').classList.remove('show');
        document.getElementById('fullscreen-btn').onclick = async () => { if(document.fullscreenElement) document.exitFullscreen(); else try { await document.documentElement.requestFullscreen(); document.body.classList.add('immersive-mode'); } catch(e){} };
        document.addEventListener('fullscreenchange', () => { if(!document.fullscreenElement) document.body.classList.remove('immersive-mode'); });
        
        // æ»‘å—ç»‘å®š
        document.getElementById('rot-slider').oninput = (e) => { GLOBAL_ROTATION_SENSITIVITY=parseFloat(e.target.value); document.getElementById('rot-val').innerText=e.target.value; };
        document.getElementById('zoom-slider').oninput = (e) => { GLOBAL_ZOOM_SENSITIVITY=parseFloat(e.target.value); document.getElementById('zoom-val').innerText=e.target.value; };
        document.getElementById('auto-rotate-toggle').onchange = (e) => AUTO_ROTATE=e.target.checked;
        document.getElementById('perf-mode-toggle').onchange = async (e) => { PERFORMANCE_MODE=e.target.checked; if(hands) await hands.setOptions({modelComplexity: PERFORMANCE_MODE?0:1, minDetectionConfidence: PERFORMANCE_MODE?0.5:0.8}); renderer.setPixelRatio(PERFORMANCE_MODE?1:Math.min(window.devicePixelRatio,2)); };
        
        document.getElementById('shape-select').onchange = (e) => { if(e.target.value.startsWith('saved_')) loadModel(parseInt(e.target.value.split('_')[1])); else { currentShapeIndex=shapeKeys.indexOf(e.target.value); morphTo(e.target.value); } };
        document.getElementById('color-picker').oninput = (e) => { defaultColor.set(e.target.value); if(!isImageMode && !document.getElementById('shape-select').value.startsWith('saved_')) morphTo(document.getElementById('shape-select').value); };
        
        // AI ç”Ÿæˆ
        document.getElementById('ai-generate-btn').onclick = async () => {
            const p = document.getElementById('ai-prompt').value.trim(); if(!p) return;
            const btn = document.getElementById('ai-generate-btn'), stat = document.getElementById('ai-status');
            btn.disabled=true; btn.innerText="ç”Ÿæˆä¸­..."; stat.innerText="AI æ€è€ƒä¸­...";
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({contents:[{parts:[{text:`Create 3D particle math JS code. Input: 'i' (index), 'PARTICLE_COUNT'. Return [x,y,z] array. Range -15 to 15. User prompt: ${p}. JSON format: {"color":"#hex", "code":"..."}`}]}]}) });
                const d = await res.json();
                const json = JSON.parse(d.candidates[0].content.parts[0].text.replace(/```json|```/g,'').trim());
                currentAICode=json.code; currentAIColor=json.color; shapes.ai_custom=new Function('i', json.code);
                defaultColor.set(json.color); document.getElementById('color-picker').value=json.color;
                document.getElementById('opt-ai').disabled=false; document.getElementById('opt-ai').text=`âœ¨ AI: ${p.substr(0,6)}`;
                document.getElementById('shape-select').value='ai_custom'; document.getElementById('save-model-btn').style.display='block';
                morphTo('ai_custom'); stat.innerText="ç”ŸæˆæˆåŠŸ";
            } catch(e) { console.error(e); stat.innerText="å¤±è´¥ï¼Œè¯·é‡è¯•"; }
            btn.disabled=false; btn.innerText="ğŸ”® ç”Ÿæˆä»£ç ";
        };

        refreshModelList();
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
